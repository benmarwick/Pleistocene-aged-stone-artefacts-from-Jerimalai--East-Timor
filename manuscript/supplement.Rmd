---
layout: 12pt,review
linenumbers: true
title: "Supplement for: "Pleistocene-aged stone artefacts from Jerimalai, East Timor: Long term conservatism in early modern human technology in island Southeast Asia""
author: 
  - name: Ben Marwick
    affiliation: uw
    email: bmarwick@uw.edu
    footnote: Corresponding author

address: 
  - code: uw
    address: | 
      Department of Anthropology, 
      Denny Hall M32, Box 353100,  
      University of Washington,
      Seattle, WA 98195-3100 USA 

output: html_document
---

```{r setup, include=FALSE, echo=FALSE}
require(knitr)
require(printr)
require(rmarkdown)
require(ggplot2)
require(reshape2)
require(plyr)
require(dplyr)
require(vcd)
require(rjags)
require(runjags)
require(coda)
require(BEST)
require(lattice)
require(xtable)
require(data.table)
require(JerimalaiStoneArtefacts)

opts_chunk$set(tidy=FALSE, warning=FALSE, message=FALSE, 
               comment = NA, verbose = TRUE, echo=TRUE)

opts_chunk$set(fig.width=4, fig.height=3, echo=FALSE)
theme_set(theme_bw(base_size=14))
toggle = "hide" # results argument

# custom functions to save figures at JHE size & resolution
# cf http://www.elsevier.com/author-schemas/artwork-and-media-instructions/artwork-sizing
jhe_190mm_ggsave <- function(filename = default_name(plot), width= 190, units = "mm", dpi= 1000, ...) {
 ggsave(filename=filename, width=width, dpi=dpi, units=units,  ...)
}
jhe_90mm_ggsave <- function(filename = default_name(plot), width= 90, units = "mm", dpi= 1000, ...) {
 ggsave(filename=filename, width=width, dpi=dpi, units=units, ...)
}

```

# Introduction

This document is part of a research compendium that accompaies the analysis of stone artefacts from Jerimalai rockshelter reported in Marwick et al. "Pleistocene-aged stone artefacts from Jerimalai, East Timor: Long term conservatism in early modern human technology in island Southeast Asia". This document is organised with the same structure as the manuscript and will produce all of the quantitative results, data visualisations and tables found in the manuscript. This document is an R markdown document, which means that it is a plain text file that contains marked-up text (such as this paragraph), and chunks of the R programming language in between paragraphs of plain text. This file may be viewed in any text editor, and executed to run the code using R version 3.2.0. 

The purpose of providing this supplement is to enable the reader to more thoroughly evaluate the reliability of our work through close inspection the quantitiative methods we used in the paper, and to enable computational reproduciblity of our methods to facailite their application to other research projects. Note that the code presented here has been developed and tested specifically for this analysis, and is not yet intended as a general purpose tool. 

## Code and Dependencies 

The exact version of the code that produced the data and figures in the published paper is archived at [http://dx.doi.org/10.6084/m9.figshare.985406](http://dx.doi.org/10.6084/m9.figshare.985406). The development version of this code can be found at [https://github.com/benmarwick/Pleistocene-aged-stone-artefacts-from-Jerimalai--East-Timor](https://github.com/benmarwick/Pleistocene-aged-stone-artefacts-from-Jerimalai--East-Timor). Note that the code in the development version on github may have changed since publication and may not produce exactly the same output as found in the published paper. 
 
The code should run on a typical personal computer (Windows/OSX/Linux) that can run R and can install R packages from the internet. The specific software dependencies for the code included here are listed in the DESCRIPTION file of the R package that this supplement file is contained in (the R package name isJerimalaiStoneArtefacts). Managing the dependencies can be tedious, and we have no control over how they will change in the future. In an effort to capture the entire computational environment that this analysis was developed and conducted in, and protect against changes in the dependant software packages, we provide a Docker image as a lightweight virtual machine that is the actual environment in which we developed, tested and ran the code. The Docker image contains all the necessary software already installed, so no further configuration is required. We also include a Dockerfile as a record of the instructions used to build the Docker image, this can be found in the `docker/` directory in the research compendium. To launch the Docker image for this project, first, [install Docker](https://docs.docker.com/installation/), then run Docker and at the Docker prompt, enter:


  docker run -dp 8787:8787 sje30/benmarwick/Pleistocene-aged-stone-artefacts-from-Jerimalai--East-Timor

Then open a web broswer at the following URL to access RStudio (username and password are "rstudio"):

    http://localhost:8787/        ## Linux users
    http://192.168.59.103:8787/   ## OSX, Windows users

Once logged in, the Files pane (bottom right) will show the `manuscript/` directory where you can find this document and execute it. More information about using RStudio in Docker is avaiable at the [Rocker](https://github.com/rocker-org) [wiki](https://github.com/rocker-org/rocker/wiki/Using-the-RStudio-image) pages.

## Data

All of the data needed to reproduce the results presented in the paper are included in this compendium as CSV files (ie. plain text comma separated variables, readable in any text editor). They can be found in the `data/` directory and are made available with a [CC-0 licence](https://creativecommons.org/publicdomain/zero/1.0/). The code chunk below loads all of the data files into the R working environment (assuming you have the working directory set to the location of this supplement file). 

```{r load_data}
# dates
dates <- read.csv("data/Jeremalai_dates.csv", as.is = TRUE)
# complete flake data
flakes <- read.csv("data/JB_Chert_Flakes_and_Retouch.csv")
# core type data
core_types <- read.csv("data/Jerimalai_cores_techno_metrics.csv")
# spit depths
depths <- read.csv("data/Jeremalai_spit_depths.csv")
# sediment volumes
vols <- read.csv("data/Artefact densities with soil volumes Sq B.csv", skip = 1)
# all artefacts
all <- read.csv("data/Jerimalai_All_Artefacts.csv")
# techno types
cores <- read.csv("data/Jerimalai_tech_table_cores.csv")
types <-  na.omit(read.csv("data/Jerimalai_tech_table_types.csv"))
retouch <- read.csv("data/Jerimalai_tech_table_retouch.csv")
features <- read.csv("data/Jerimalai_tech_table_features.csv")
ground <- read.csv("data/Jerimalai_tech_table_ground.csv")
# retouch indices
retouch_indices <- read.csv("data/Jerimalai_retouch_indices.csv")
```

# Chronology of the excavated deposit

The code chunk below reproduces Figure 2, the depth-age distribution for radiocarbon dates from Jerimalai. 


```{r fig_2_chronology}
# plot dates and label with phases
dates$cal_age_min <- as.numeric(gsub("\\D", "", dates$cal_age_min))
dates$cal_age_max <- as.numeric(gsub("\\D", "", dates$cal_age_max))
dates$mid <- with(dates, cal_age_min + ((cal_age_max - cal_age_min) /2) )
ggplot(dates, aes(mid, depth_bs)) +
  geom_point(size = 3) +
  scale_y_reverse() + 
  geom_errorbarh(aes(xmin=cal_age_min,xmax=cal_age_max,  height = 0)) +
  #geom_smooth(span = 0.19, se = FALSE) +
  ylab("depth below surface (m)") +
  xlab("calibrated age (BP)") +
  geom_vline(xintercept = 42000, colour = 'grey') +
  annotate("text", x = 40000, y = 0.25, label = "Phase I", angle = 90) + 
  geom_vline(xintercept = 38000, colour = 'grey') +
  geom_vline(xintercept = 17000, colour = 'grey') +
  annotate("text", x = 25000, y = 0.25, label = "Phase II", angle = 90) + 
  geom_vline(xintercept = 9000, colour = 'grey') +
  annotate("text", x = 14000, y = 0.25, label = "Phase III", angle = 90) + 
  geom_vline(xintercept = 5500, colour = 'grey') +
  annotate("text", x = 7000, y = 0.25, label = "Phase IV", angle = 90) +
  geom_vline(xintercept = 5500,colour = 'grey') +
  geom_vline(xintercept = 0, colour = 'grey') +
  annotate("text", x = 3500, y = 0.25, label = "Phase V", angle = 90)
  theme( # remove the vertical grid lines
    panel.grid.major.x = element_blank() ,
    # explicitly set the horizontal lines (or they will disappear too)
    panel.grid.major.y = element_blank()  
  )
# save to png file 
jhe_190mm_ggsave("figures/fig_2-Jeremalai-dates.png")
```

# Results: Raw materials

The code chunk below computes the percentages of the two major cortex types for chert flakes, and displays the result in a table.

```{r chert_cortex_type}
cortex_type <- as.data.frame(table(flakes$Cortype))[-1,]
cortex_type$prop <- round(prop.table(cortex_type$Freq),2)
names(cortex_type)  <- c("Cortex type", "Frequency", "Proportion")
kable(cortex_type, caption = "Cortex type among chert flakes")
```

The chunk above also generates the values that are found in this sentence in the manuscript: "The chert artefacts have a combination of rounded cortex (`r filter(cortex_type, Var1 == 'Round')$prop * 100`%) and angular cortex (`r filter(cortex_type, Var1 == 'Angul')$prop * 100`%.")

The code chunk below subsets the stone artefact data so that we only include flakes without any missing mass data. We then assign each flake to a depositional phase based on the spit it was recovered from. There is no visual output from this chunk but the values are stored and used in the following chunks. 

```{r lithics_subset_and_assign_to_phase}
# omit rows with blanks or NAs
flakes <- flakes[!(flakes$Weight == "" | is.na(flakes$Weight)), ]

# put depths on lithic data
flakes$depth <- depths$Depth.bs..m[match(flakes$Spit,depths$Spit.no)]

# omit rows with blanks or NAs... again
flakes <- flakes[!(flakes$depth == "" | is.na(flakes$depth)), ]

flakes$phase <- ifelse(flakes$Spit > 0 & flakes$Spit <= 20, 4,
                       ifelse(flakes$Spit >= 21 & flakes$Spit <= 39, 3,
                              ifelse(flakes$Spit >= 40 & flakes$Spit <= 49, 2,
                                     ifelse(flakes$Spit >= 50 & flakes$Spit <= 69, 1, NA))))
# check if any NA
check <- unique(flakes$phase)

# here's a function to assign phases based on spit numbers
  makephases <- function(x) {ifelse(x > 0 & x <= 20, 5,
                       ifelse(x >= 21 & x <= 39, 4,
                              ifelse(x >= 40 & x <= 48, 3,
                                     ifelse(x >= 49 & x <= 55, 2,
                                            ifelse(x >= 56 & x <= 69, 1, NA)))))}

flakes <- flakes[!(is.na(flakes$Spit)),]
flakes$phase  <- makephases(flakes$Spit)
# check if any NA, don't want any, should return all TRUE
# is.na(unique(flakes$phase)) %in% FALSE
# get phase durations
phases <- data.frame(phase = 1:5,
                     start = c(42, 38, 17, 6.5, 5.5),
                     end =   c(38, 17, 9,  5.5, 0 ))
phases$duration <- with(phases, start - end)
```

The code chunk below generates a table that summarises the frequencies of the main raw materials in each depositional phase. A raw material is considered dominant here if there are more than ten peices in a phase. 

```{r lithics_raw_material_over_time}
# raw material
raw <- dcast(flakes, Material ~ phase) 
# remove row with no raw material
raw <- raw[-10,]
rownames(raw) <- raw[,1]
# get rid of rows with no value
raw <- raw[rownames(raw) != "",]
# remove col of NA
raw <- raw[,colnames(raw) != "NA"]
raw <- raw[,-1]
# subset dominant raw materials
dom <- raw[rowSums(raw) > 10,]
colnames(dom) <- c("phase 1", "phase 2", "phase 3", "phase 4", "phase 5" )
kable(dom, caption = "Frequencies of dominant raw materials by depositional phase")
```

The code chunk below uses the Bayesian Poisson exponential ANOVA to compute the probabilities of any credible interactions between raw material frequencies and depositional phase. The goal is to determine if there are any significant changes in the use of raw materials for stone artefacts over time.

```{r raw_material_by_phase_test_bayes}
data <- melt(as.matrix(dom),  varnames=c("raw_material", "phase"), value.name="Freq")
myDataFrame = data
yName=names(myDataFrame)[3]   # Freq
x1Name=names(myDataFrame)[2]  # phase 
x2Name=names(myDataFrame)[1]  # raw material
x1contrasts = list( 
  list( c("phase 1")  , c("phase 2") , compVal=0.0 , ROPE=c(-0.1,0.1) ) ,
  list( c("phase 2")  , c("phase 3") , compVal=0.0 , ROPE=c(-0.1,0.1)) ,
  list( c("phase 3")  , c("phase 4") , compVal=0.0 , ROPE=c(-0.1,0.1)) , 
  list( c("phase 4")  , c("phase 5") , compVal=0.0 , ROPE=c(-0.1,0.1))
  )
numSavedSteps = 12000 # MCMC parameters
thinSteps = 10        # MCMC parameters

mcmcCoda = genMCMC_cont_table( datFrm=myDataFrame , 
                    yName=yName , x1Name=x1Name , x2Name=x2Name ,
                    numSavedSteps=numSavedSteps , thinSteps=thinSteps , 
                    )

# Get summary statistics of chain:
summaryInfo = smryMCMC_cont_table( mcmcCoda , 
                        datFrm=myDataFrame , x1Name=x1Name , x2Name=x2Name ,
                        x1contrasts=x1contrasts 
                         )

# #  Display posterior information (not easy to read unless using interactively):
#     plotMCMC_cont_table( mcmcCoda , 
#               datFrm=myDataFrame , yName=yName , x1Name=x1Name , 
#                x2Name=x2Name ,
#               x1contrasts=x1contrasts  )

# subset summaryInfo to show HDI interval for interactions
HDI_intervals_for_interactions <- summaryInfo[117:120, c("HDIlow", "HDIhigh")]
kable(HDI_intervals_for_interactions, caption = "Highest density intervals (95%) for the posterior distributions of the interactions between phases and raw material frequencies.")
```

The code chunk above povides psoterior distributions to evaluate the credibility of differences in raw material frequences over time. The posterior distributions for the phase interactions are close to zero, indicating a small effect. Among the contrast of the phases, all HDIs exclude zero except for phase 4 v. phase 5. This indicates that there are credibly different frequencies of raw material between each phase except for four and five. This is likely are result of small changes in the low frequencies of quartz, quartzite and silcrete in the earlier phases, as shown in the phase by raw material table above. 

The code chunk below computes a NHST equivalent to the above Bayesian test, in this case a chi-square test. We also compute Cramer's V, a measure of association for nominal variables that ranges from 0 (no association between the variables) to 1 (strong association between the variables).

```{r raw_material_by_phase_test_nhst}
# here is the frequentist equivalent 
raw_material_by_phase_nhst <- chisq.test(dom)
cramers_V <- assocstats(as.matrix(dom)) 
```

The code chunk above returns a chi-squared value of `r raw_material_by_phase_nhst$statistic` and a p-value of `r raw_material_by_phase_nhst$p.value`, indicating a signficant difference in raw material frequencies by phase. However, the Cramer's V value of `r cramers_V$cramer` indicates that the effect size is extremely small. We interpret this result to mean that there is no substantial significance in the differences in raw materials frequencies by phase. 

# Results: Discard rates

The code chunk below generates the figure that shows discard rates of chert artefacts over time at Jerimalai square B. Each point is an excavation unit. The blue line is a locally weighted regression line (span = 0.4) to aid in visualising the trend of increased discard in the upper part of the deposit.

```{r discard_over_time_fig_3}
# discard rates
discard <- aggregate(Weight ~ depth + Spit, flakes, length)
# sediment volumes: put volumes on
discard$sedvol <- vols$Soil[match(discard$Spit, vols$X)]
# put spit thickesses on
discard$thick <- c(0.018, diff(discard$depth)) # add first value from depth_and_dates.xsl
# compute artefacts per kg of sediment
discard$kgsed <- with(discard, Weight / sedvol) # weight is count of artefacts that have a weight
# compute artefact per cubic meter (spit thickess)
discard$cubmet <- with(discard, Weight / thick)
# seems we have an unusually extreme value in spit 34
# omit - perhaps a data collection typo
discard <- discard[discard$Spit != 34, ]
# Plot
ggplot(discard, (aes(depth, cubmet))) +
  geom_point() +
  stat_smooth(span = 0.5, se = FALSE) +
  xlab("Depth below surface (m)") +
  ylab("Number of chert flakes per \ncubic meter of deposit") +
  coord_flip() +
  scale_x_reverse()
# save plot
jhe_90mm_ggsave("figures/fig_3_Jeremalai-flake-discard.png")
```

The code chunk below the generates the figure showing discard rates of chert artefacts per depositional phase at Jerimalai square B. This aggregates the individual excavation units.

```{r discard_by_phase_fig_4}
# plot artefacts/cubic meter/1000 years by phase, get phase number for each spit
# this is the most sensible option
discard$phase <- makephases(discard$Spit)
discard_agg <- aggregate(cubmet ~ phase, discard, mean)
discard_agg$cubmetperkyr <- discard_agg$cubmet / phases$duration
ggplot(discard_agg, (aes(phase, cubmetperkyr))) +
  geom_bar(stat="identity") +
  theme_minimal() +
  xlab("Depositional phase") +
  ylab("Mean number of chert flakes per \ncubic meter of deposit per thousand years") 
# save plot
jhe_90mm_ggsave("figures/fig_4_Jeremalai-flake-discard-phase-m3.png", height = 90)
```

# Results: Artefact taphonomy

The code chunk below computes a Bayesian Poisson exponential ANOVA to investigate differences in flake breakage classes over time. 

```{r artefact_taphonomy_bayes}
allchert <- all[all$Material == 'Chert', ]
allchert$phase <- makephases(allchert$Spit)
# make Artclass that is long and transv breaks
allchert$Artclas <- ifelse(allchert$Breaks == "", 
       as.character(allchert$Artclas), 
       paste(allchert$Artclas, allchert$Breaks, sep = "-"))
taph <- data.frame(table(allchert$Artclas))
# use regex to get broken flakes -b- 
broken <- allchert[grep("-b", allchert$Artclas), ]
# get counts of broken to complete per phase
# flake to -b-
breaks <- dcast(allchert, Artclas ~ phase)[-1,]
breaks <- breaks[breaks$Artclas =="Flake" | grepl("-b-", breaks$Artclas), ]
allchert$Artclas <- tolower(allchert$Artclas)
allchert$breakt <- "" # create variable to fill
allchert$breakt[grep("trans", allchert$Artclas)] <- "trans"
allchert$breakt[grep("long", allchert$Artclas)] <- "long"
# per depositional phase
breakt <- dcast(allchert, breakt ~ phase)[-1,]
# add complete flake counts
breakt <- rbind( breakt , setNames( breaks[1, ] , names( breakt ) ) )
# shift rownames out and delete them
rownames(breakt) <- breakt[,1]
breakt <- breakt[,-1]
# do bayesian contingency table test
colnames(breakt) <- c("phase 1", "phase 2", "phase 3", "phase 4", "phase 5" )
data <- melt(as.matrix(breakt),  varnames=c("breakt", "phase"), value.name="Freq")
myDataFrame = data
yName=names(myDataFrame)[3]   # Freq 
x1Name=names(myDataFrame)[2]  # phase
x2Name=names(myDataFrame)[1]  # break type
x1contrasts = list( 
  list( c("phase 1") , c("phase 2") , compVal=0.0 , ROPE=c(-0.1,0.1) ) ,
  list( c("phase 2")  , c("phase 3") , compVal=0.0 , ROPE=c(-0.1,0.1)) ,
  list( c("phase 3")  , c("phase 4") , compVal=0.0 , ROPE=c(-0.1,0.1)) , 
  list( c("phase 4")  , c("phase 5") , compVal=0.0 , ROPE=c(-0.1,0.1))
  )
numSavedSteps = 12000 # MCMC parameters
thinSteps = 10        # MCMC parameters

mcmcCoda = genMCMC_cont_table( datFrm=myDataFrame , 
                    yName=yName , x1Name=x1Name , x2Name=x2Name ,
                    numSavedSteps=numSavedSteps , thinSteps=thinSteps , 
                    )

# Get summary statistics of chain:
summaryInfo = smryMCMC_cont_table( mcmcCoda , 
                        datFrm=myDataFrame , x1Name=x1Name , x2Name=x2Name ,
                        x1contrasts=x1contrasts 
                         )

# #  Display posterior information (not easy to read unless using interactively):
#     plotMCMC_cont_table( mcmcCoda , 
#               datFrm=myDataFrame , yName=yName , x1Name=x1Name , 
#                x2Name=x2Name ,
#               x1contrasts=x1contrasts  )

# table of raw counts
kable(breakt, caption = "Table of frequencies of each class of breakage by phase")

# subset summaryInfo to show HDI interval for interactions
HDI_intervals_for_interactions <- summaryInfo[66:69, c("HDIlow", "HDIhigh")]
kable(HDI_intervals_for_interactions, caption = "Highest density intervals (95%) for the posterior distributions of the interactions between phases and flake breakage classes.")
```

The above code chunk returns results that there are credible difference but small differences in the frequences of flake breakage types by phase. 

The code chunk below computes the frequentist equivalent, the chi-square test and the Cramer's V for effect size. 

```{r artefact_taphonomy_nhst}
artefact_taphonomy_nhst <- assocstats(as.matrix(breakt))
```

The code chunk above returns a chi-squared value of `r artefact_taphonomy_nhst$chisq_tests[2,1]` and a p-value of `r artefact_taphonomy_nhst$chisq_tests[2,3]`, indicating a signficant difference in frequencies of breakage classes by phase. However, the Cramer's V value of `r artefact_taphonomy_nhst$cramer` indicates that the effect size is extremely small. We interpret this result to mean that although the test result is statistically significant, there is no substantial significance in the differences in frequencies of breakage types by phase. 

The code chunk below draws a plot of frequencies of complete flakes, transversely broken flakes and longitudinally broken flakes made from chert in each depositional unit at Jerimalai square B.

```{r fig5_chert_breakage}

data$phase <- gsub("[[:alpha:]]*", "", data$phase)
# recode break type for pretty legend
data$breakt_ <- with(data, ifelse(breakt == 'long', 'long. broken flakes',
        ifelse(breakt == "trans", "trans. broken flakes",
               ifelse(breakt == "Flake", "complete flakes", NA))))
ggplot(data, aes(phase, Freq, fill = breakt_)) +
  ylab("Frequency") +
  geom_bar(stat = "identity") +
  scale_fill_discrete(name="flake type") +
  xlab("depositional phase") +
  theme_minimal((base_size = 6))
jhe_90mm_ggsave("figures/fig_5_Jeremalai-flake-broken-phase.png", height = 90/2)
```

The code chunk below summarises the frequencies of heat-treated flakes at Jerimalai square B

```{r lithics_heat_treatment}
check <- sum(flakes$Heat, na.rm = TRUE) / nrow(flakes)
heat <- aggregate(Heat ~ phase, flakes, length)
total <- aggregate(Spit ~ phase, flakes, length)
heat$Not_heat <- total$Spit - heat$Heat
# show proportions that are heat-treated
max_heat <- max(heat$Heat / total$Spit)
min_heat <- min(heat$Heat / total$Spit)
heat <- t(heat)
# do bayesian contingency table test
colnames(heat) <- c("phase 1", "phase 2", "phase 3", "phase 4", "phase 5" )
heat <- heat[-1,]
```

Between `r round(min_heat, 2)*100`% and `r round(max_heat, 2)*100`% of chert artefacts in each depositional phase show signs of having been heated, such as crenation, potlid scars or surface crazing. 

The code chunk below computes a Bayesian Poisson exponential ANOVA to investigate differences in heat treatment by phase. 

```{r lithics_heat_treatment_bayes}
data <- melt(as.matrix(heat),  varnames=c("heat", "phase"), value.name="Freq")
myDataFrame = data
yName=names(myDataFrame)[3]   # Freq 
x1Name=names(myDataFrame)[2]  # phase
x2Name=names(myDataFrame)[1]  # heat
x1contrasts = list( 
  list( c("phase 1") , c("phase 2") , compVal=0.0 , ROPE=c(-0.1,0.1) ) ,
  list( c("phase 2")  , c("phase 3") , compVal=0.0 , ROPE=c(-0.1,0.1)) ,
  list( c("phase 3")  , c("phase 4") , compVal=0.0 , ROPE=c(-0.1,0.1)) , 
  list( c("phase 4")  , c("phase 5") , compVal=0.0 , ROPE=c(-0.1,0.1))
  )
numSavedSteps = 12000 # MCMC parameters
thinSteps = 10        # MCMC parameters

mcmcCoda = genMCMC_cont_table( datFrm=myDataFrame , 
                    yName=yName , x1Name=x1Name , x2Name=x2Name ,
                    numSavedSteps=numSavedSteps , thinSteps=thinSteps , 
                    )

# Get summary statistics of chain:
summaryInfo = smryMCMC_cont_table( mcmcCoda , 
                        datFrm=myDataFrame , x1Name=x1Name , x2Name=x2Name ,
                        x1contrasts=x1contrasts 
                         )

# #  Display posterior information (not easy to read unless using interactively):
    plotMCMC_cont_table( mcmcCoda , 
              datFrm=myDataFrame , yName=yName , x1Name=x1Name , 
               x2Name=x2Name ,
              x1contrasts=x1contrasts  )

# table of heated artefact counts
kable(heat, caption = "Table of frequencies of heat treatment by phase")

# subset summaryInfo to show HDI interval for interactions
HDI_intervals_for_interactions <- summaryInfo[49:52, c("HDIlow", "HDIhigh")]
kable(HDI_intervals_for_interactions, caption = "Highest density intervals (95%) for the posterior distributions of the interactions between phases and flake breakage classes.")
```

The code chunk above returned results that indicate credible differences in the frequency of heat treatment between each phase except for phase one and two. The phase three to four transition is particularly different from the others, but this corresponds to only a `r round(abs(heat[1,3]/sum(heat[1:2,3]) -  heat[1,4]/sum(heat[1:2,4]) * 100),1)`% change increase in frequency of heated peices. all the HDIs are close to zero, indicating a small effect size. 
The code chunk below computes a frequentist chi-square and Cramer's V test for the heat treatment data.

```{r chert_artefacts_heat_nhst}
chert_artefacts_heat_nhst <- assocstats(as.matrix(heat))
```

The code chunk above returns a chi-squared value of `r chert_artefacts_heat_nhst$chisq_tests[2,1]` and a p-value of `r chert_artefacts_heat_nhst$chisq_tests[2,3]`, indicating a signficant difference in frequencies of breakage classes by phase. However, the Cramer's V value of `r chert_artefacts_heat_nhst$cramer` indicates that the effect size is extremely small. We interpret this result to mean that although the test result is statistically significant, there is no substantial significance in the differences in frequencies of breakage types by phase.


# Results: Metric and technological characteristics of cores and unretouched flakes 

The code chunk below produces the table "summarizing the attributes of chert complete flakes from Jerimalai square B. Each cell contains mean ± standard deviation unless otherwise indicated. The table produced here has been rearranged by hand for the paper.

```{r chert_flake_metrics_summary_table_6}
# the table has been rearranged by hand for the paper
metrics <- flakes %>% 
  group_by(phase) %>% 
  summarise(mean(Length, na.rm = TRUE),  
            mean(Width, na.rm = TRUE), 
            mean(Thick, na.rm = TRUE),
            mean(Weight, na.rm = TRUE),
            mean(Length, na.rm = TRUE),
            mean(Platwid, na.rm = TRUE),
            mean(Platthic, na.rm = TRUE),
            mean(NoDS, na.rm = TRUE),
            mean(Cortex, na.rm = TRUE),
            sd(Length, na.rm = TRUE),  
            sd(Width, na.rm = TRUE), 
            sd(Thick, na.rm = TRUE),
            sd(Weight, na.rm = TRUE),
            sd(Length, na.rm = TRUE),
            sd(Platwid, na.rm = TRUE),
            sd(Platthic, na.rm = TRUE),
            sd(NoDS, na.rm = TRUE),
            sd(Cortex, na.rm = TRUE),
            n = length(Weight))

# get overhang removal data also
ohr <- filter(flakes, Overhang == "Yes") %>%
       group_by(phase) %>%
       summarise(OHR_n = length(Overhang))
# get percentages of OHR per phase
ohr$OHR_perc <- ohr$OHR_n/metrics$n * 100

# combine
metrics <- cbind(metrics, ohr[,c("OHR_n", "OHR_perc")])
metrics <- t(round(metrics,2))
# save as CSV to tidy up, there is no simple way to make the table
# that appears in the paper
write.csv(metrics, "figures/table_6_flake_metrics.csv")
```

The code chunk below uses a Bayesian one-way ANOVA to investigate differences in chert flake mass by depostitional phase. 

```{r chert_flake_metrics_summary_test_bayes}
myDataFrame <- data.frame(phase = flakes$phase, mass = flakes$Weight)
yName = names(myDataFrame)[2] # mass
xName = names(myDataFrame)[1] # phase
contrasts = list( 
  list( c("phase 1") , c("phase 2") , compVal=0.0 , ROPE=c(-0.1,0.1) ) ,
  list( c("phase 2")  , c("phase 3") , compVal=0.0 , ROPE=c(-0.1,0.1)) ,
  list( c("phase 3")  , c("phase 4") , compVal=0.0 , ROPE=c(-0.1,0.1)) , 
  list( c("phase 4")  , c("phase 5") , compVal=0.0 , ROPE=c(-0.1,0.1))
  )
  # Generate the MCMC chain:
  mcmcCoda_ANOVA = genMCMC_ANOVA(datFrm=myDataFrame , yName=yName , xName=xName ,
                      numSavedSteps=11000 , thinSteps=10 
                      )
  # Get summary statistics of chain:
  summaryInfo_ANOVA = smryMCMC_ANOVA( mcmcCoda_ANOVA , 
                          datFrm=myDataFrame , xName=xName ,
                          contrasts=contrasts 
                          )

```

```{r}
# ANOVA with Tukey's HSD
fit <- aov(Weight ~ as.factor(phase), flakes)
# summary(fit)
tuk <- TukeyHSD(fit)
# plot(tuk, las = 2, cex = 0.1)

```

# Results: Core technology

# Results: Retouched artefacts 

# Results: Technological types

