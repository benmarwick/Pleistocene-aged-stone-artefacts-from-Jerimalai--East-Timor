---
layout: 12pt,review
linenumbers: true
title: "Supplement for: "Pleistocene-aged stone artefacts from Jerimalai, East Timor: Long term conservatism in early modern human technology in island Southeast Asia""
author: 
  - name: Ben Marwick
    affiliation: uw
    email: bmarwick@uw.edu
    footnote: Corresponding author

address: 
  - code: uw
    address: | 
      Department of Anthropology, 
      Denny Hall M32, Box 353100,  
      University of Washington,
      Seattle, WA 98195-3100 USA 

output: html_document
---

```{r setup, include=FALSE, echo=FALSE}
require(knitr)
require(printr)
require(rmarkdown)
require(ggplot2)
require(reshape2)
require(plyr)
require(dplyr)
require(vcd)
require(rjags)
require(coda)
require(BEST)
require(lattice)
require(xtable)
require(data.table)

opts_chunk$set(tidy=FALSE, warning=FALSE, message=FALSE, 
               comment = NA, verbose = TRUE, echo=TRUE)

opts_chunk$set(fig.width=4, fig.height=3, echo=FALSE)
theme_set(theme_bw(base_size=12))
toggle = "hide" # results argument

# custom functions to save figures at JHE size & resolution
# cf http://www.elsevier.com/author-schemas/artwork-and-media-instructions/artwork-sizing
jhe_190mm_ggsave <- function(filename = default_name(plot), width= 190, units = "mm", dpi= 1000, ...) {
 ggsave(filename=filename, width=width, dpi=dpi, units=units,  ...)
}
jhe_90mm_ggsave <- function(filename = default_name(plot), width= 90, units = "mm", dpi= 1000, ...) {
 ggsave(filename=filename, width=width, dpi=dpi, units=units, ...)
}

```

# Introduction

This document is part of a research compendium that accompaies the analysis of stone artefacts from Jerimalai rockshelter reported in Marwick et al. "Pleistocene-aged stone artefacts from Jerimalai, East Timor: Long term conservatism in early modern human technology in island Southeast Asia". This document is organised with the same structure as the manuscript and will produce all of the quantitative results, data visualisations and tables found in the manuscript. This document is an R markdown document, which means that it is a plain text file that contains marked-up text (such as this paragraph), and chunks of the R programming language in between paragraphs of plain text. This file may be viewed in any text editor, and executed to run the code using R version 3.2.0. 

The purpose of providing this supplement is to enable the reader to more thoroughly evaluate the reliability of our work through close inspection the quantitiative methods we used in the paper, and to enable computational reproduciblity of our methods to facailite their application to other research projects. Note that the code presented here has been developed and tested specifically for this analysis, and is not yet intended as a general purpose tool. 

## Code and Dependencies 

The exact version of the code that produced the data and figures in the published paper is archived at [http://dx.doi.org/10.6084/m9.figshare.985406](http://dx.doi.org/10.6084/m9.figshare.985406). The development version of this code can be found at [https://github.com/benmarwick/Pleistocene-aged-stone-artefacts-from-Jerimalai--East-Timor](https://github.com/benmarwick/Pleistocene-aged-stone-artefacts-from-Jerimalai--East-Timor). Note that the code in the development version on github may have changed since publication and may not produce exactly the same output as found in the published paper. 
 
The code should run on a typical personal computer (Windows/OSX/Linux) that can run R and can install R packages from the internet. The specific software dependencies for the code included here are listed in the DESCRIPTION file of the R package that this supplement file is contained in (the R package name isJerimalaiStoneArtefacts). Managing the dependencies can be tedious, and we have no control over how they will change in the future. In an effort to capture the entire computational environment that this analysis was developed and conducted in, and protect against changes in the dependant software packages, we provide a Docker image as a lightweight virtual machine that is the actual environment in which we developed, tested and ran the code. The Docker image contains all the necessary software already installed, so no further configuration is required. We also include a Dockerfile as a record of the instructions used to build the Docker image, this can be found in the `docker/` directory in the research compendium. To launch the Docker image for this project, first, [install Docker](https://docs.docker.com/installation/), then run Docker and at the Docker prompt, enter:


  docker run -dp 8787:8787 sje30/benmarwick/Pleistocene-aged-stone-artefacts-from-Jerimalai--East-Timor

Then open a web broswer at the following URL to access RStudio (username and password are "rstudio"):

    http://localhost:8787/        ## Linux users
    http://192.168.59.103:8787/   ## OSX, Windows users

Once logged in, the Files pane (bottom right) will show the `manuscript/` directory where you can find this document and execute it. More information about using RStudio in Docker is avaiable at the [Rocker](https://github.com/rocker-org) [wiki](https://github.com/rocker-org/rocker/wiki/Using-the-RStudio-image) pages.

## Data

All of the data needed to reproduce the results presented in the paper are included in this compendium as CSV files (ie. plain text comma separated variables, readable in any text editor). They can be found in the `data/` directory and are made available with a [CC-0 licence](https://creativecommons.org/publicdomain/zero/1.0/). The code chunk below loads all of the data files into the R working environment (assuming you have the working directory set to the location of this supplement file). 


```{r load_data}
# dates
dates <- read.csv("data/Jeremalai_dates.csv", as.is = TRUE)
# complete flake data
flakes <- read.csv("data/JB_Chert_Flakes_and_Retouch.csv")
# core type data
core_types <- read.csv("data/Jerimalai_cores_techno_metrics.csv")
# spit depths
depths <- read.csv("data/Jeremalai_spit_depths.csv")
# sediment volumes
vols <- read.csv("data/Artefact densities with soil volumes Sq B.csv", skip = 1)
# all artefacts
all <- read.csv("data/Jerimalai_All_Artefacts.csv")
# techno types
cores <- read.csv("data/Jerimalai_tech_table_cores.csv")
types <-  na.omit(read.csv("data/Jerimalai_tech_table_types.csv"))
retouch <- read.csv("data/Jerimalai_tech_table_retouch.csv")
features <- read.csv("data/Jerimalai_tech_table_features.csv")
ground <- read.csv("data/Jerimalai_tech_table_ground.csv")
# retouch indices
retouch_indices <- read.csv("data/Jerimalai_retouch_indices.csv")
```


# Chronology of the excavated deposit

The code chunk below reproduces Figure 2, the depth-age distribution for radiocarbon dates from Jerimalai. 


```{r fig_2_chronology}
# plot dates and label with phases
dates$cal_age_min <- as.numeric(gsub("\\D", "", dates$cal_age_min))
dates$cal_age_max <- as.numeric(gsub("\\D", "", dates$cal_age_max))
dates$mid <- with(dates, cal_age_min + ((cal_age_max - cal_age_min) /2) )
ggplot(dates, aes(mid, depth_bs)) +
  geom_point() +
  scale_y_reverse() + 
  geom_errorbarh(aes(xmin=cal_age_min,xmax=cal_age_max,  height = 0)) +
  theme_minimal() +
  #geom_smooth(span = 0.19, se = FALSE) +
  ylab("depth below surface (m)") +
  xlab("calibrated age (BP)") +
  geom_vline(xintercept = 42000, colour = 'grey') +
  annotate("text", x = 40000, y = 0.25, label = "Phase I", angle = 90) + 
  geom_vline(xintercept = 38000, colour = 'grey') +
  geom_vline(xintercept = 17000, colour = 'grey') +
  annotate("text", x = 25000, y = 0.25, label = "Phase II", angle = 90) + 
  geom_vline(xintercept = 9000, colour = 'grey') +
  annotate("text", x = 14000, y = 0.25, label = "Phase III", angle = 90) + 
  geom_vline(xintercept = 5500, colour = 'grey') +
  annotate("text", x = 7000, y = 0.25, label = "Phase IV", angle = 90) +
  geom_vline(xintercept = 5500,colour = 'grey') +
  geom_vline(xintercept = 0, colour = 'grey') +
  annotate("text", x = 3500, y = 0.25, label = "Phase V", angle = 90)
  theme( # remove the vertical grid lines
    panel.grid.major.x = element_blank() ,
    # explicitly set the horizontal lines (or they will disappear too)
    panel.grid.major.y = element_blank()  
  )
# save to png file 
jhe_190mm_ggsave("figures/fig_2-Jeremalai-dates.png")
```

# Results: Raw materials

The code chunk below computes the percentages of the two major cortex types for chert flakes, and displays the result in a table.

```{r chert_cortex_type}
cortex_type <- as.data.frame(table(flakes$Cortype))[-1,]
cortex_type$prop <- round(prop.table(cortex_type$Freq),2)
names(cortex_type)  <- c("Cortex type", "Frequency", "Proportion")
kable(cortex_type, caption = "Cortex type among chert flakes")
```

The chunk above also generates the values that are found in this sentence in the manuscript: "The chert artefacts have a combination of rounded cortex (`r filter(cortex_type, Var1 == 'Round')$prop * 100`%) and angular cortex (`r filter(cortex_type, Var1 == 'Angul')$prop * 100`%.")

The code chunk below subsets the stone artefact data so that we only include flakes without any missing mass data. We then assign each flake to a depositional phase based on the spit it was recovered from. There is no visual output from this chunk but the values are stored and used in the following chunks. 

```{r lithics_subset_and_assign_to_phase}
# omit rows with blanks or NAs
flakes <- flakes[!(flakes$Weight == "" | is.na(flakes$Weight)), ]

# put depths on lithic data
flakes$depth <- depths$Depth.bs..m[match(flakes$Spit,depths$Spit.no)]

# omit rows with blanks or NAs... again
flakes <- flakes[!(flakes$depth == "" | is.na(flakes$depth)), ]

flakes$phase <- ifelse(flakes$Spit > 0 & flakes$Spit <= 20, 4,
                       ifelse(flakes$Spit >= 21 & flakes$Spit <= 39, 3,
                              ifelse(flakes$Spit >= 40 & flakes$Spit <= 49, 2,
                                     ifelse(flakes$Spit >= 50 & flakes$Spit <= 69, 1, NA))))
# check if any NA
check <- unique(flakes$phase)

# here's a function to assign phases based on spit numbers
  makephases <- function(x) {ifelse(x > 0 & x <= 20, 5,
                       ifelse(x >= 21 & x <= 39, 4,
                              ifelse(x >= 40 & x <= 48, 3,
                                     ifelse(x >= 49 & x <= 55, 2,
                                            ifelse(x >= 56 & x <= 69, 1, NA)))))}

flakes <- flakes[!(is.na(flakes$Spit)),]
flakes$phase  <- makephases(flakes$Spit)
# check if any NA, don't want any, should return all TRUE
# is.na(unique(flakes$phase)) %in% FALSE
# get phase durations
phases <- data.frame(phase = 1:5,
                     start = c(42, 38, 17, 6.5, 5.5),
                     end =   c(38, 17, 9,  5.5, 0 ))
phases$duration <- with(phases, start - end)
```


The code chunk below 

```{r lithics_raw_material_over_time}
# raw material
raw <- dcast(flakes, Material ~ phase) 
# remove row with no raw material
raw <- raw[-10,]
rownames(raw) <- raw[,1]
# get rid of rows with no value
raw <- raw[rownames(raw) != "",]
# remove col of NA
raw <- raw[,colnames(raw) != "NA"]
raw <- raw[,-1]
# subset dominant raw materials
dom <- raw[rowSums(raw) > 10,]
colnames(dom) <- c("phase 1", "phase 2", "phase 3", "phase 4", "phase 5" )
```


dom_m <- dom
dom_m$raw_type <- rownames(dom_m) 
dom_m <- melt(dom_m)
ggplot(dom_m, aes(variable, value, fill = raw_type)) + 
  geom_bar(stat="identity") +
  theme_minimal() +
  xlab("Depositional phase") +
  ylab("Artefact frequency") +
  scale_fill_discrete(name="Raw material")
# save plot
ggsave("figures/Jeremalai-raw-materials-group-counts.png")

# table: subset raw materials with more than 10 pieces per phase, 
# include obsidian ouot of interest
dom_obs <- raw[rowSums(raw) > 10 | row.names(raw) == 'Obsidian',]
#print(xtable(dom_obs), type = 'html', html.table.attributes = (border=0), file = "raw_tab.html")

raw_freqs <- data.frame(raw_types = rownames(raw), Freq = rowSums(raw))
ggplot(raw_freqs, aes(reorder(raw_types, Freq), Freq)) + 
  geom_bar(stat="identity")
# raw materials by site
# compute proportions per layer (col props)
all_tab <- data.frame()
for(i in seq(ncol(raw))){
  for(j in seq(nrow(raw))){
    all_tab[j,i] <- raw[j,i]/colSums(raw)[i]
  }
}
# check 
# colSums(all_tab) # should == 1
# colnames(all_tab) <- colnames(raw) 
# rowSums(all_tab) # should be various
all_tab$raw_type <- rownames(raw) 
# get rid of raw materials that are not very abundant
all_tab <- all_tab[which(rowSums(all_tab[,1:ncol(all_tab)-1]) > 0.02) , ]

# get rid of NA column
all_tab <- all_tab[,names(all_tab) != 'NA']
# set column names
colnames(all_tab) <- c("phase 1", "phase 2", "phase 3", "phase 4", "phase 5", "raw_type" )

# plot
all_tab_m <- melt(all_tab, id.var = 'raw_type')
ggplot(all_tab_m, aes(variable, value, fill = raw_type)) + 
  geom_bar(stat="identity") +
  theme_minimal() +
  xlab("Depth below surface (m)") +
  ylab("Proportion of depositional phase") +
  scale_fill_discrete(name="Raw material")
# save plot
ggsave("figures/Jeremalai-raw-materials-group.png")
```

```{r raw_material_by_phase_test}
# bayesian contingency table test...
# reshape and give meaningful names...

data <- melt(as.matrix(dom),  varnames=c("raw_material", "phase"), value.name="Freq")
data <- data[data$Freq != 0 | !is.numeric(data$Freq),] # zeros break the model

# This script is in the same folder as the current script
# and generates plots and a lot of data objects. The only 
# input is a long data.frame called 'data' that has a last
# column called 'Freq'

# uncomment this next line to run test (it will take a few minutes)
# source("code/BensPoissonExponentialJagsSTZ.R")

# 2nd edition
# source("code/Jags-Ycount-Xnom2fac-MpoissonExp.R")

myDataFrame = data

yName=names(myDataFrame)[1] # raw material
x1Name=names(myDataFrame)[2]  # phase
x2Name=names(myDataFrame)[3]  # Freq
x1contrasts = list( 
  list( c("phase 1") , c("phase 2") , compVal=0.0 , ROPE=c(-0.1,0.1) ) ,
  list( c("phase 2")  , c("phase 3") , compVal=0.0 , ROPE=c(-0.1,0.1)) ,
  list( c("phase 3")  , c("phase 4") , compVal=0.0 , ROPE=c(-0.1,0.1)) , 
  list( c("phase 4")  , c("phase 5") , compVal=0.0 , ROPE=c(-0.1,0.1))
  )

numSavedSteps = 12000
thinSteps = 10

mcmcCoda = genMCMC( datFrm=myDataFrame , 
                    yName=yName , x1Name=x1Name , x2Name=x2Name ,
                    numSavedSteps=numSavedSteps , thinSteps=thinSteps , 
                    )
#------------------------------------------------------------------------------- 
# Display diagnostics of chain, for specified parameters:
parameterNames = varnames(mcmcCoda) 
show( parameterNames ) # show all parameter names, for reference
for ( parName in c("b0","b1[1]","b2[1]","b1b2[1,1]","ppx1x2p[1,1]",
                   "a1SD","a1a2SD") ) {
  diagMCMC( codaObject=mcmcCoda , parName=parName  )
}
#------------------------------------------------------------------------------- 
# Get summary statistics of chain:
summaryInfo = smryMCMC( mcmcCoda , 
                        datFrm=myDataFrame , x1Name=x1Name , x2Name=x2Name ,
                        x1contrasts=x1contrasts 
                         )
show(summaryInfo)
# Display posterior information:
plotMCMC( mcmcCoda , 
          datFrm=myDataFrame , 
          yName=yName , 

          x1contrasts=x1contrasts )

# all interactions include zero in the HDI, so no credible differences 
# in raw materials between phases. 
```

```{r }

# here is the frequentist equivalent 

results <- chisq.test(raw, simulate.p.value=T, B=9999)
# a few diagnostics
# results$expected
# prop.table(raw)
# colSums(prop.table(raw))
# rowSums(prop.table(raw))
# stat test on just dominant materials
tab <- prop.table(as.matrix(raw[rowSums(raw) > 20,]), 2)
# a slight decrease in chert in Holocene
result <- chisq.test(dom, simulate.p.value=FALSE, B=999)

# so it's significant in the frequentist system, but what's the strength?
# Cramer's V: is a measure of association for nominal variables. Effectively it is the Pearson chi-square statistic rescaled to have values between 0 and 1,
cramers_V <- assocstats(as.matrix(dom)) # very small V

```

# Results: Discard rates

# Results: Artefact taphonomy 

# Results: Metric and technological characteristics of cores and unretouched flakes 

# Results: Core technology

# Results: Retouched artefacts 

# Results: Technological types

You can also embed plots, for example:

```{r, echo=FALSE}
plot(cars)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
